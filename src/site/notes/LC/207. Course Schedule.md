---
{"dg-publish":true,"permalink":"/lc/207-course-schedule/","tags":["graph","dfs","bfs"]}
---

>[!Problem]
>There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.
> 
> - For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.
> 
> Return `true` if you can finish all courses. Otherwise, return `false`.
> 
> **Example 1:**
> 
> **Input:** numCourses = 2, prerequisites = [[1,0\|1,0]]
> **Output:** true
> **Explanation:** There are a total of 2 courses to take. 
> To take course 1 you should have finished course 0. So it is possible.
> 
> **Example 2:**
> 
> **Input:** numCourses = 2, prerequisites = [[1,0],[0,1\|1,0],[0,1]]
> **Output:** false
> **Explanation:** There are a total of 2 courses to take. 
> To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
> 
> **Constraints:**
> 
> - `1 <= numCourses <= 2000`
> - `0 <= prerequisites.length <= 5000`
> - `prerequisites[i].length == 2`
> - `0 <= ai, bi < numCourses`
> - All the pairs prerequisites[i] are **unique**.

# Solution 1: [[DFS#Iterative\|DFS#Iterative]]
- **Time Complexity**: $O(n\times(n + m))$
- **Space Complexity**: $O(n)$
# Intuition
- Build graph and then use [[DFS#Iterative\|DFS#Iterative]] on each course to check for cycles
- One optimization is, while building graph, can create set of courses which have pre-requisites and check only for those

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = [[] for _ in range(numCourses)]
        has_requisite = [False for _ in range(numCourses)]

        for u, v in prerequisites:
            graph[u].append(v)
            has_requisite[u] = True

        for course in range(numCourses):
            if not has_requisite[course]:
                continue

            stack = [course]
            visited = [False for _ in range(numCourses)]

            while stack:
                node = stack.pop()
                visited[node] = True
                # has_requisite[node] = False

                for neighbor in graph[node]:
                    if neighbor == course:
                        return False
                    if not visited[neighbor]:
                        stack.append(neighbor)

        return True
```

# Solution 2: [[DFS#Recursive\|DFS#Recursive]]
- **Time Complexity**: $O(n + m)$
- **Space Complexity**: $O(n)$

## Intuition
- Same as above but do DFS recursively
- When done recursively, we can track if a course has been completely checked and later when it comes in path of another course, we can skip it

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = [[] for _ in range(numCourses)]
        check = set()
        for u, v in prerequisites:
            graph[u].append(v)
            check.add(u)
        
        state = [0] * numCourses
    
        def hasCycle(node):
            if state[node] == 1:
                return False
            elif state[node] == -1:
                return True
            
            state[node] = -1

            for neighbor in graph[node]:
                if hasCycle(neighbor):
                    return True
            
            state[node] = 1
            return False
        
        for course in check:
            if hasCycle(course):
                return False
        
        return True
```