---
{"dg-publish":true,"permalink":"/lc/1370-increasing-decreasing-string/","tags":["radixSort","string"]}
---

>[!Problem]
>You are given a string `s`. Reorder the string using the following algorithm:
> 1. Remove the **smallest** character from `s` and **append** it to the result.
> 2. Remove the **smallest** character from `s` that is greater than the last appended character, and **append** it to the result.
> 3. Repeat step 2 until no more characters can be removed.
> 4. Remove the **largest** character from `s` and **append** it to the result.
> 5. Remove the **largest** character from `s` that is smaller than the last appended character, and **append** it to the result.
> 6. Repeat step 5 until no more characters can be removed.
> 7. Repeat steps 1 through 6 until all characters from `s` have been removed.
> 
> If the smallest or largest character appears more than once, you may choose any occurrence to append to the result.
> 
> Return the resulting string after reordering `s` using this algorithm.
> 
> **Example 1:**
> 
> **Input:** s = "aaaabbbbcccc"
> **Output:** "abccbaabccba"
> **Explanation:** After steps 1, 2 and 3 of the first iteration, result = "abc"
> After steps 4, 5 and 6 of the first iteration, result = "abccba"
> First iteration is done. Now s = "aabbcc" and we go back to step 1
> After steps 1, 2 and 3 of the second iteration, result = "abccbaabc"
> After steps 4, 5 and 6 of the second iteration, result = "abccbaabccba"
> 
> **Example 2:**
> 
> **Input:** s = "rat"
> **Output:** "art"
> **Explanation:** The word "rat" becomes "art" after re-ordering it with the mentioned algorithm.
> 
> **Constraints:**
> 
> - `1 <= s.length <= 500`
> - `s` consists of only lowercase English letters.

# Solution 1: Radix Sort
- **Time Complexity**: $O(n \times 26 \times 2)$
- **Space Complexity**: $O(26)$

## Intuition
- At first glance, this looks like running first two steps until exhaustion, then next two steps until exhaustion, put it all into a while loop. 
- The optimization here is that we can flatten the search for consecutively increasing min characters by iterating in alphabetic order, and do inverse for decreasing max characters
- Just fill a character counter at start and use it in the loops

```cpp
class Solution {
public:
    string sortString(string s) {
        string result = "";
        int counter[26] = {0};
        for (const char& ch : s) {
            int index = ch - 'a';
            counter[index]++;
        }

        int n = s.length();
        while (n) {
            for (int i = 0; i < 26; i++) {
                if (counter[i]) {
                    result.push_back(i + 'a');
                    counter[i]--;
                    n--;
                }
            }
            for (int i = 25; i >= 0; i--) {
                if (counter[i]) {
                    result.push_back(i + 'a');
                    counter[i]--;
                    n--;
                }
            }
        }

        return result;
    }
};
```

# Solution 2: Ordered [[Hashing\|Hashing]]
- **Time Complexity**: $O(n \log{n})$
- **Space Complexity**: $O(n)$

## Intuition
- Same concept as above, instead of iterating through all 26 characters (some may not be present in string), use an ordered [[Hashing#Hash Map\|Hashing#Hash Map]] for the counter and iterate through it