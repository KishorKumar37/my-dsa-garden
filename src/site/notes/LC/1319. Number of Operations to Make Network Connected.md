---
{"dg-publish":true,"permalink":"/lc/1319-number-of-operations-to-make-network-connected/","tags":["unionFind"]}
---

>[!Problem]
>There are `n` computers numbered from `0` to `n - 1` connected by ethernet cables `connections` forming a network where `connections[i] = [ai, bi]` represents a connection between computers `ai` and `bi`. Any computer can reach any other computer directly or indirectly through the network.
> You are given an initial computer network `connections`. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.
> 
> Return _the minimum number of times you need to do this in order to make all the computers connected_. If it is not possible, return `-1`.
> 
> **Example 1:**
> 
> ![](https://assets.leetcode.com/uploads/2020/01/02/sample_1_1677.png)
> 
> **Input:** n = 4, connections = `[[0,1],[0,2],[1,2]]`
> **Output:** 1
> **Explanation:** Remove cable between computer 1 and 2 and place between computers 1 and 3.
> 
> **Example 2:**
> 
> ![](https://assets.leetcode.com/uploads/2020/01/02/sample_2_1677.png)
> 
> **Input:** n = 6, connections = `[[0,1],[0,2],[0,3],[1,2],[1,3]]`
> **Output:** 2
> 
> **Example 3:**
> 
> **Input:** n = 6, connections = `[[0,1],[0,2],[0,3],[1,2]]`
> **Output:** -1
> **Explanation:** There are not enough cables.
> 
> **Constraints:**
> 
> - `1 <= n <= 105`
> - `1 <= connections.length <= min(n * (n - 1) / 2, 105)`
> - `connections[i].length == 2`
> - `0 <= ai, bi < n`
> - `ai != bi`
> - There are no repeated connections.
> - No two computers are connected by more than one cable.

# Solution
- **Time Complexity**: $O()$
- **Space Complexity**: $O()$

## Intuition
- It is very similar to [[LC/3608. Minimum Time for K Connected Components\|3608. Minimum Time for K Connected Components]]
- Use [[Union Find Algorithm\|Union Find Algorithm]]. Count the number of islands and the number of redundant edges during unite operation
- To join $n$ islands, we need $n-1$ edges
- So, if we have enough redundant edges, $n-1$ is the answer, else return $-1$

```cpp
class DisjointSet {
private:
    vector<int> parent;
    int redundantEdges;
    int islands;
public:
    DisjointSet(int size) {
        parent.resize(size);
        for (int i = 0; i < size; i++) {
            parent[i] = i;
        }
        islands = size;
        redundantEdges = 0;
    }
    int find(int key) {
        if (parent.at(key) == key) return key;
        return parent[key] = find(parent.at(key));
    }
    void unite(int key1, int key2) {
        int parent1 = find(key1);
        int parent2 = find(key2);

        if (parent1 == parent2) redundantEdges++;
        else {
            parent[parent1] = parent2;
            islands--;
        }
    }
    int getIslands() {
        return islands;
    }
    int getRedundantEdges() {
        return redundantEdges;
    }
};

class Solution {
public:
    int makeConnected(int n, vector<vector<int>>& connections) {
        DisjointSet* disjointSet = new DisjointSet(n);

        for (vector<int>& connection : connections) {
            disjointSet->unite(connection.at(0), connection.at(1));
        }

        int redundantEdges = disjointSet->getRedundantEdges();
        int islands = disjointSet->getIslands();

        if (redundantEdges >= islands - 1) return islands - 1;
        else return -1;
    }
};
```