---
{"dg-publish":true,"permalink":"/lc/15-3-sum/"}
---

> [!Problem]
> Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.
> 
> Notice that the solution set must not contain duplicate triplets.
> 
> **Example 1:**
> 
> **Input:** nums = [-1,0,1,2,-1,-4]
> **Output:** [[-1,-1,2],[-1,0,1\|-1,-1,2],[-1,0,1]]
> **Explanation:** 
> nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
> nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
> nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
> The distinct triplets are [-1,0,1] and [-1,-1,2].
> Notice that the order of the output and the order of the triplets does not matter.
> 
> **Example 2:**
> 
> **Input:** nums = [0,1,1]
> **Output:** []
> **Explanation:** The only possible triplet does not sum up to 0.
> 
> **Example 3:**
> 
> **Input:** nums = [0,0,0]
> **Output:** [[0,0,0\|0,0,0]]
> **Explanation:** The only possible triplet sums up to 0.
> 
> **Constraints:**
> 
> - `3 <= nums.length <= 3000`
> - `-105 <= nums[i] <= 105`

# Solution 1: Sorting and [[Greedy Algorithms\|Greedy Search]]
- **Time Complexity**: $O(n^2)$
- **Space Complexity**: $O(1)$

## Intuition
- Searching for 3 numbers which obey a condition requires 3 loops so brute force is $O(n^3$)
- Fix one element in loop, then select other 2 in remaining elements using [[Two Pointer#Front and Back type\|Two Pointer#Front and Back type]]
- The search for 2nd and 3rd number (front and back pointers) can be done faster if the array is sorted. Since we are aiming for $O(n^2)$, sorting with $O(\log{n})$ is fine
- Move the pointers based on whether we want a larger sum or smaller sum to reach the target. One we move either pointer, it is a sub-problem with same set of constraints. Hence, we can [[Greedy Algorithms\|greedily]] move the pointers
- Array can have duplicates, so include loops to move the pointer further if same elements occur (sorted array)

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res: list(int) = []

        for i in range(0, len(nums) - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            j: int = i + 1
            k: int = len(nums) - 1

            while j < k:
                total: int = nums[i] + nums[j] + nums[k]
                
                if total > 0:
                    k -= 1
                    while nums[k] == nums[k] + 1 and j < k:
                        k -= 1
                elif total < 0:
                    j += 1
                    while nums[j] == nums[j] - 1 and j < k:
                        j += 1
                else:
                    res.append([nums[i], nums[j], nums[k]])
                    k -= 1
                    while nums[k] == nums[k] + 1 and j < k:
                        k -= 1
                    j += 1
                    while nums[j] == nums[j] - 1 and j < k:
                        j += 1
        
        return res
```

# Solution 2: Hashing
[[LC/16. 3Sum Closest#Solution 1 Hashing\|16. 3Sum Closest#Solution 1 Hashing]]