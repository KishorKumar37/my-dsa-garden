---
{"dg-publish":true,"permalink":"/lc/81-search-in-rotated-sorted-array-ii/","tags":["binarySearch","array"]}
---

> [!Problem]
> There is an integer array `nums` sorted in non-decreasing order (not necessarily with **distinct** values).
> 
> Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.
> 
> Given the array `nums` **after** the rotation and an integer `target`, return `true` _if_ `target` _is in_ `nums`_, or_ `false` _if it is not in_ `nums`_._
> 
> You must write an algorithm with `O(log n)` runtime complexity. You must decrease the overall operation steps as much as possible.
> 
> **Example 1:**
> 
> **Input:** nums = [4,5,6,7,0,1,2], target = 0
> **Output:** 4
> 
> **Example 2:**
> 
> **Input:** nums = [4,5,6,7,0,1,2], target = 3
> **Output:** -1
> 
> **Example 3:**
> 
> **Input:** nums = [1], target = 0
> **Output:** -1
> 
> **Constraints:**
> 
> - `1 <= nums.length <= 5000`
> - `-104 <= nums[i] <= 104`
> - All values of `nums` are **unique**.
> - `nums` is an ascending array that is possibly rotated.
> - `-104 <= target <= 104`

# Solution
- **Time Complexity**: $O(\log{n})$
- **Space Complexity**: $O(1)$

## Intuition
- Similar to [[LC/33. Search in Rotated Sorted Array\|33. Search in Rotated Sorted Array]]
- But presence of duplicates will give rise to a special case where `arr[l] == arr[m] == arr[r] and l != m != r`
- This will confuse the algorithm as both parts are not sorted, so for this special case we will move both `l` and `r` pointers

```python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        l = 0
        r = len(nums) - 1

        while l <= r:
            m = (l + r) // 2
            if nums[m] == target:
                return True

            if nums[l] == nums[m] and nums[m] == nums[r]:
                l += 1
                r -= 1
            elif nums[l] <= nums[m]: # Left side is sorted
                if nums[l] <= target < nums[m]:
                    r = m - 1
                else:
                    l = m + 1
            elif nums[m] <= nums[r]:
                if nums[m] < target <= nums[r]:
                    l = m + 1
                else:
                    r = m - 1
        
        return False
```