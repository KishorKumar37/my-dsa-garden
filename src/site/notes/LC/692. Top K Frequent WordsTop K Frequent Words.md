---
{"dg-publish":true,"permalink":"/lc/692-top-k-frequent-words-top-k-frequent-words/","tags":["string","hashing","trie","priorityQueue"]}
---

>[!Problem]
>Given an array of strings `words` and an integer `k`, return _the_ `k` _most frequent strings_.
> Return the answer **sorted** by **the frequency** from highest to lowest. Sort the words with the same frequency by their **lexicographical order**.
> 
> **Example 1:**
> 
> **Input:** words = ["i","love","leetcode","i","love","coding"], k = 2
> **Output:** ["i","love"]
> **Explanation:** "i" and "love" are the two most frequent words.
> Note that "i" comes before "love" due to a lower alphabetical order.
> 
> **Example 2:**
> 
> **Input:** words = ["the","day","is","sunny","the","the","the","sunny","is","is"], k = 4
> **Output:** ["the","is","sunny","day"]
> **Explanation:** "the", "is", "sunny" and "day" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.
> 
> **Constraints:**
> 
> - `1 <= words.length <= 500`
> - `1 <= words[i].length <= 10`
> - `words[i]` consists of lowercase English letters.
> - `k` is in the range `[1, The number of **unique** words[i]]`
> 
> **Follow-up:** Could you solve it in `O(n log(k))` time and `O(n)` extra space?

# Solution 1: Bucket Sort similar to [[LC/347. Top K Frequent Elements#Solution 3 Bucket Sort\|347. Top K Frequent Elements#Solution 3 Bucket Sort]]
- **Time Complexity**: $O(n \log{n})$
- **Space Complexity**: $O(n)$
## Intuition
- Read solution from link for intuition
- But this is not $O(n)$ because when listing in lexicographical order, sorting takes $O(U \log{U})$ where $U$ is size of bucket, but if all words are unique then $U = n$
```python
class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        counter = defaultdict(int)

        for word in words:
            counter[word] += 1
        
        buckets = [[] for _ in range(len(words))]

        for word, count in counter.items():
            buckets[count].append(word)
        
        del counter

        result = []
        for bucket in reversed(buckets):
            for word in sorted(bucket):
                result.append(word)
                k -= 1

                if k == 0:
                    return result
```
# Solution 2: Priority Queue of fixed size (similar to [[LC/347. Top K Frequent Elements#Solution 2 Priority Queue of fixed size\|347. Top K Frequent Elements#Solution 2 Priority Queue of fixed size]])
- **Time Complexity**: $O(n \log{k})$
- **Space Complexity**: $O(n)$
## Intuition
- Read solution from link for intuition
- We don't need to sort here, instead when heap is full, also break tie between the min element and current word
